diff --git a/node_modules/@terrysahaidak/style-thing/hoist.ts b/node_modules/@terrysahaidak/style-thing/hoist.ts
new file mode 100644
index 0000000..53335af
--- /dev/null
+++ b/node_modules/@terrysahaidak/style-thing/hoist.ts
@@ -0,0 +1,146 @@
+import React from 'react';
+
+const hasSymbol = typeof Symbol === 'function' && Symbol.for;
+
+// copied from react-is
+const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
+const REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
+
+/**
+ * Adapted from hoist-non-react-statics to avoid the react-is dependency.
+ */
+const REACT_STATICS = {
+  childContextTypes: true,
+  contextType: true,
+  contextTypes: true,
+  defaultProps: true,
+  displayName: true,
+  getDefaultProps: true,
+  getDerivedStateFromError: true,
+  getDerivedStateFromProps: true,
+  mixins: true,
+  propTypes: true,
+  type: true,
+};
+
+const KNOWN_STATICS = {
+  name: true,
+  length: true,
+  prototype: true,
+  caller: true,
+  callee: true,
+  arguments: true,
+  arity: true,
+};
+
+const FORWARD_REF_STATICS = {
+  $$typeof: true,
+  render: true,
+  defaultProps: true,
+  displayName: true,
+  propTypes: true,
+};
+
+const MEMO_STATICS = {
+  $$typeof: true,
+  compare: true,
+  defaultProps: true,
+  displayName: true,
+  propTypes: true,
+  type: true,
+};
+
+const TYPE_STATICS = {
+  [REACT_FORWARD_REF_TYPE]: FORWARD_REF_STATICS,
+  [REACT_MEMO_TYPE]: MEMO_STATICS,
+};
+
+type OmniComponent = React.ComponentType | React.ExoticComponent;
+
+// adapted from react-is
+function isMemo(object: OmniComponent | React.MemoExoticComponent<any>) {
+  const $$typeofType = 'type' in object && object.type.$$typeof;
+
+  return $$typeofType === REACT_MEMO_TYPE;
+}
+
+function getStatics(component: OmniComponent) {
+  // React v16.11 and below
+  if (isMemo(component)) {
+    return MEMO_STATICS;
+  }
+
+  // React v16.12 and above
+  return '$$typeof' in component
+    ? TYPE_STATICS[component['$$typeof'] as unknown as string]
+    : REACT_STATICS;
+}
+
+const defineProperty = Object.defineProperty;
+const getOwnPropertyNames = Object.getOwnPropertyNames;
+const getOwnPropertySymbols = Object.getOwnPropertySymbols;
+const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
+const getPrototypeOf = Object.getPrototypeOf;
+const objectPrototype = Object.prototype;
+
+type ExcludeList = {
+  [key: string]: true;
+};
+
+type NonReactStatics<S extends OmniComponent, C extends ExcludeList = {}> = {
+  [key in Exclude<
+    keyof S,
+    S extends React.MemoExoticComponent<any>
+      ? keyof typeof MEMO_STATICS | keyof C
+      : S extends React.ForwardRefExoticComponent<any>
+      ? keyof typeof FORWARD_REF_STATICS | keyof C
+      : keyof typeof REACT_STATICS | keyof typeof KNOWN_STATICS | keyof C
+  >]: S[key];
+};
+
+export default function hoistNonReactStatics<
+  T extends OmniComponent,
+  S extends OmniComponent,
+  C extends ExcludeList = {}
+>(targetComponent: T, sourceComponent: S, excludelist?: C) {
+  if (typeof sourceComponent !== 'string') {
+    // don't hoist over string (html) components
+
+    if (objectPrototype) {
+      const inheritedComponent = getPrototypeOf(sourceComponent);
+      if (inheritedComponent && inheritedComponent !== objectPrototype) {
+        hoistNonReactStatics(targetComponent, inheritedComponent, excludelist);
+      }
+    }
+
+    let keys: (String | Symbol)[] = getOwnPropertyNames(sourceComponent);
+
+    if (getOwnPropertySymbols) {
+      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
+    }
+
+    const targetStatics = getStatics(targetComponent);
+    const sourceStatics = getStatics(sourceComponent);
+
+    for (let i = 0; i < keys.length; ++i) {
+      const key = keys[i] as unknown as string;
+      if (
+        !(key in KNOWN_STATICS) &&
+        !(excludelist && excludelist[key]) &&
+        !(sourceStatics && key in sourceStatics) &&
+        !(targetStatics && key in targetStatics)
+      ) {
+        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
+
+        try {
+          // Avoid failures from read-only properties
+          defineProperty(targetComponent, key, descriptor!);
+        } catch (e) {
+          /* ignore */
+        }
+      }
+    }
+  }
+
+  return targetComponent as T & NonReactStatics<S, C>;
+}
diff --git a/node_modules/@terrysahaidak/style-thing/index.js b/node_modules/@terrysahaidak/style-thing/index.js
index 9215226..1425600 100644
--- a/node_modules/@terrysahaidak/style-thing/index.js
+++ b/node_modules/@terrysahaidak/style-thing/index.js
@@ -1,133 +1,194 @@
 import React from 'react';
-import styledComponent, { css, useTheme } from 'styled-components';
-
+import styledComponent, { css } from 'styled-components';
+import hoist from './hoist';
 // eslint-disable-next-line import/no-commonjs
 const reactNative = require('react-native');
+const ThemeContext = React.createContext();
+
+function useTheme() {
+  return React.useContext(ThemeContext);
+}
 
-function getProps(props, attrs, theme, config) {
-  const propsWithTheme = { ...props, theme };
-  let propsToUse = {};
+export function StyleThingThemeProvider({ value, children }) {
+  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
+}
 
-  if (typeof config?.shouldForwardProp === 'function') {
-    const keys = Object.keys(propsWithTheme);
+// eslint-disable-next-line import/no-commonjs
+// const reactNative = require('react-native');
+
+function filterProps(props, shouldForwardProp) {
+  if (typeof shouldForwardProp === 'function') {
+    const forwardedProps = {};
+    const keys = Object.keys(props);
     for (let i = 0; i < keys.length; i++) {
       const key = keys[i];
 
-      if (config?.shouldForwardProp(key, () => true)) {
-        propsToUse[key] = propsWithTheme[key];
+      
+      if (shouldForwardProp(key, () => true)) {
+        forwardedProps[key] = props[key];
       }
     }
+    return forwardedProps;
   } else {
-    propsToUse = propsWithTheme;
+    return props;
   }
+}
 
-  // .attrs((props) => ({}))
-  if (typeof attrs === 'function') {
-    attrs = attrs(propsToUse);
-  }
+function useResolvedAttrs(theme = {}, props, attrs = []) {
+  // NOTE: can't memoize this
+  // returns [context, resolvedAttrs]
+  // where resolvedAttrs is only the things injected by the attrs themselves
+  const context = { ...props, theme };
+  const resolvedAttrs = {};
+
+  for (let i = 0; i < attrs.length; i++) {
+    const attrDef = attrs[i];
+    let resolvedAttrDef = typeof attrDef === 'function' ? attrDef(context) : attrDef;
+    let key;
 
-  // .attrs({})
-  if (typeof attrs === 'object') {
-    propsToUse = { ...propsToUse, ...attrs };
+    for (key in resolvedAttrDef) {
+      context[key] = resolvedAttrs[key] = resolvedAttrDef[key];
+    }
   }
 
-  return propsToUse;
+  return [context, resolvedAttrs];
 }
 
-function getStyles(styles, props) {
-  // (props) => style
-  if (typeof styles === 'function') {
-    return {
-      generatedStyles: styles(props),
-    };
-  } else {
-    const generatedStyles = {};
-    const staticStyles = {};
+function processStyles(nestedStyles, props) {
+  let result = {};
 
-    const keys = Object.keys(styles);
-    for (let i = 0; i < keys.length; i++) {
-      const key = keys[i];
-      const item = styles[key];
+  for (let i = 0; i < nestedStyles.length; i++) {
+    const styles = nestedStyles[i];
     
-      if (typeof item === 'function') {
-        generatedStyles[key] = item(props);
-      } else {
-        staticStyles[key] = item;
+    if (typeof styles === 'function') {
+      Object.assign(result, styles(props));
+    } else if (typeof styles === 'object') {
+      const keys = Object.keys(styles);
+      for (let i = 0; i < keys.length; i++) {
+        const key = keys[i];
+        const item = styles[key];
+
+        result[key] = typeof item === 'function' ? item(props) : item;
       }
     }
-
-    return {
-      generatedStyles,
-      staticStyles,
-    };
   }
+
+  return result;
 }
 
-ex/**
- *
- *
- * @param {*} props
- * @returns
- */
-function attrs(props) {
-    StyledComponentFactory.attrs = props;
+export default function styled(Component) {
+  function attrs(props) {
+    StyledComponentFactory.addedAttrs = props;
     return StyledComponentFactory;
   }
 
   function withConfig(config) {
-    StyledComponentFactory.__config = config;
+    if (config?.shouldForwardProp) {
+      StyledComponentFactory.shouldForwardProp = config.shouldForwardProp;
+    }
+
     return StyledComponentFactory;
   }
 
-  function StyledComponentFactory(...args) {
-    // console.log(args);
-    const [styles, ...rest] = args;
   
-    // if (Array.isArray(styles)) {
-    //   let instance = styledComponent(Component);
+  function StyledComponentFactory(styles) {
+    let WrappedStyledComponent;
     
-    //   if (StyledComponentFactory.__config) {
-    //     instance = instance.withConfig(StyledComponentFactory.__config);
-    //   }
+    let shouldForwardProp = StyledComponentFactory.shouldForwardProp;
     
-    //   if (StyledComponentFactory.__attrs) {
-    //     instance = instance.attrs(StyledComponentFactory.__attrs);
-    //   }
-
-    //   return instance(styles.concat(rest));
-    // }
 
     function StyledComponent({ style, ...props }, ref) {
-      const theme = useTheme();
-
-      const propsToUse = getProps(
-        props,
-        StyledComponentFactory.attrs,
-        theme,
-        StyledComponentFactory.__config
-      );
-
-      const { staticStyles, generatedStyles } = getStyles(styles, propsToUse);
-
-      return (
-        <Component
-          ref={ref}
-          {...propsToUse}
-          style={[staticStyles, generatedStyles, style]}
-        />
-      );
+      const theme = useTheme() ?? {};
+
+      
+      const [context, attributes] = useResolvedAttrs(theme, props, WrappedStyledComponent.attrs);
+
+      const elementToBeCreated = attributes?.$as || props.$as || attributes?.as || props.as || WrappedStyledComponent.target
+
+      const generatedStyles = processStyles(WrappedStyledComponent.styles, context);
+
+      const computedProps = { ...props, ...attributes };
+
+      const forwardedProps = filterProps(computedProps, WrappedStyledComponent.shouldForwardProp);
+
+      forwardedProps.ref = ref;
+
+      forwardedProps.style = [generatedStyles];
+
+      if (style) {
+        if (Array.isArray(style)) {
+          forwardedProps.style.push(...style)
+        } else {
+          forwardedProps.style.push(style);
+        }
+      }
+
+      if (props.css) {
+        forwardedProps.style.push(css);
+      }
+
+      return React.createElement(elementToBeCreated, forwardedProps);
+    }
+
+    WrappedStyledComponent = React.memo(React.forwardRef(StyledComponent));
+
+    WrappedStyledComponent.displayName = `StyledThing${Component.name}`;
+
+    WrappedStyledComponent.isStyledComponent = true;
+
+    WrappedStyledComponent.target = Component.isStyledComponent ? Component.target : Component;
+
+    if (StyledComponentFactory.addedAttrs) {
+      WrappedStyledComponent.attrs = Array.isArray(Component.attrs) 
+        ? Component.attrs.concat(StyledComponentFactory.addedAttrs) 
+        : [StyledComponentFactory.addedAttrs];
+    } else {
+      WrappedStyledComponent.attrs = Component.attrs;
     }
 
-    const memoized = React.memo(React.forwardRef(StyledComponent));
 
-    memoized.displayName = `StyledThing${Component.name}`;
+    WrappedStyledComponent.styles = Array.isArray(Component.styles) 
+      ? Component.styles.concat(styles) 
+      : [styles];
+    
+    
+
+    if (Component.isStyledComponent && Component.shouldForwardProp) {
+      const shouldForwardPropFn = Component.shouldForwardProp;
 
-    return memoized;
+      if (StyledComponentFactory.shouldForwardProp) {
+        const passedShouldForwardPropFn = StyledComponentFactory.shouldForwardProp;
+
+        
+        // compose nested shouldForwardProp calls
+        shouldForwardProp = (prop, filterFn) =>
+        shouldForwardPropFn(prop, filterFn) &&
+        passedShouldForwardPropFn(prop, filterFn);
+      } else {
+        // eslint-disable-next-line prefer-destructuring
+        shouldForwardProp = shouldForwardPropFn;
+      }
+    }
+
+    WrappedStyledComponent.shouldForwardProp = shouldForwardProp;
+
+    hoist(WrappedStyledComponent, Component, {
+      // all SC-specific things should not be hoisted
+      attrs: true,
+      styles: true,
+      displayName: true,
+      shouldForwardProp: true,
+      isStyledComponent: true,
+      target: true,
+    });
+
+    return WrappedStyledComponent;
   }
 
   StyledComponentFactory.attrs = attrs;
   StyledComponentFactory.withConfig = withConfig;
 
+
   return StyledComponentFactory;
 }
 
